import numpy as np
from numpy.linalg import norm   
from math import * 
from BoundBox import BoundBox

class Triangle:

    kEpsilon = 0.0000001
        
    def normalize(self, v):
        def magnitude(v):
            return sqrt(sum(v[i]*v[i] for i in range(len(v))))
        vmag = magnitude(v)
        return np.array([ v[i]/vmag  for i in range(len(v)) ])

    def __init__(self, p1, p2, p3, color, ka, kd, ks, mat, ref):
        self.p1 = p1
	self.ref= ref
        self.p2 = p2
        self.p3 = p3
        self.color = color
        self.mat = mat
        self.ka = ka
        self.kd = kd
        self.ks = ks
#        self.n = np.cross(p1 - p3, p1 - p2)
        self.n = np.cross(p2 - p1, p3 - p1)
        self.n = self.normalize(self.n)
        maxx = max(p1[0], p2[0], p3[0])
        minx = min(p1[0], p2[0], p3[0])
        maxy = max(p1[1], p2[1], p3[1])
        miny = min(p1[1], p2[1], p3[1])
        maxz = max(p1[2], p2[2], p3[2])
        minz = min(p1[2], p2[2], p3[2])
#        print p1
#        print p2
#        print p3
        self.box = BoundBox(maxx, minx, maxy, miny, maxz, minz)
#        print maxx, minx, maxy, miny, maxz, minz
        
        

    def intersectRay(self, ray):
    	def area(a,b,c):
	        return 0.5 * norm( np.cross(b - a, c - a) )
        def SameSide(p1,p2, a,b):
            cp1 = np.cross(b-a, p1-a)
            cp2 = np.cross(b-a, p2-a)
            if np.dot(cp1, cp2) >= 0 : return True
            else :return False

        def PointInTriangle(p, a,b,c):
            if SameSide(p,a, b,c) and SameSide(p,b, a,c) and SameSide(p,c, a,b) : return True
            else : return False
        temp = ray.d
        t = np.dot(temp, self.n)
        if t == 0 : return None
        temp = self.p1 - ray.o
        temp  =np.dot(temp,self.n)
        t = temp / t
        p = ray.o + t*ray.d
        if t <= 0 :
            return None
        if PointInTriangle(p, self.p1, self.p2, self.p3) :
            return t
        else  : return None
#        areaWhole = area(self.p1, self.p2, self.p3)
#        area1 = area(self.p1, self.p2, p)
#        area2 = area(self.p2, self.p3, p)
#        area3 = area(self.p3, self.p1, p)
#        b1 = area1 / areaWhole
#        b2 = area2 / areaWhole
#        b3 = area3 / areaWhole
#        if 0 <= b1 and b1 <= 1 and 0 <= b2 and b2 <= 1 and 0 <= b3 and b3 <= 1 :
#            print p
#            print b1, b2, b3
#            return t
#        else :
#			return None
#


    def getNormal(self,xp):
        return self.n

   
